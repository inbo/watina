% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get.R
\name{get_locs}
\alias{get_locs}
\title{Get locations from the database}
\usage{
get_locs(
  con,
  filterdepth_range = c(0, 3),
  filterdepth_na = FALSE,
  obswells = FALSE,
  mask = NULL,
  join_mask = FALSE,
  buffer = 10,
  bbox = NULL,
  area_codes = NULL,
  loc_type = c("P", "S", "R", "N", "W", "D", "L", "B"),
  loc_validity = c("VLD", "ENT"),
  loc_vec = NULL,
  collect = FALSE
)
}
\arguments{
\item{con}{A \code{DBIConnection} object to Watina.
See \code{\link{connect_watina}} to generate one.}

\item{filterdepth_range}{Numeric vector of length 2.
Specifies the allowed range of the depth of the filter bottom below soil
surface, as meters (minimum and maximum allowed filterdepth, respectively).
This condition is only applied to groundwater piezometers.
The second vector element cannot be smaller than the first.
With \code{obswells = FALSE}, a location is kept whenever one observation
well fulfills the criterion.}

\item{filterdepth_na}{Logical.
Are observation wells with missing filterdepth value to be included?
Defaults to \code{FALSE}.}

\item{obswells}{Logical.
If \code{TRUE}, the returned object distinguishes all observation wells that
meet the \code{filterdepth_range} criterion.
If \code{FALSE} (the default), the returned object just distinguishes
locations.
Please note the meaning of observation well in Watina: if there are multiple
observation wells attached to one location, these belong to
\emph{other timeframes}!
So one location always coincides with exactly one observation well at
one moment in time.
Multiple observation wells can succeed one another because of physical
alterations (e.g. damage of a piezometer).
Here, the term 'observation well' is used to refer to a fixed installed
device in the field (groundwater piezometer, surface water level
measurement device).}

\item{mask}{An optional geospatial filter of class \code{sf}.
If provided, only locations that intersect with \code{mask} will be returned,
with the value of \code{buffer} taken into account.
The CRS must be Belgian Lambert 72 (EPSG-code
\href{https://epsg.io/31370}{31370}).}

\item{join_mask}{Logical.
Do you want to spatially join the attribute columns of \code{mask} to the
resulting tibble?
The spatial join is executed with
\code{\link[sf:geos_binary_pred]{st_intersects()}} as the topological operator.
Beware: if the same location intersects with more than one element of
\code{mask} (taking into account the value of \code{buffer}), that location
will occur multiple times in the result.
\code{join_mask} is ignored if \code{mask} is not provided.}

\item{buffer}{Number of meters taken as a buffer to enlarge
\code{mask} (or shrink it, if \code{buffer < 0}) if \code{mask} is provided.}

\item{bbox}{Optional geospatial fiter (rectangle).
A bounding box (class \code{bbox}), or a vector of four named elements
\code{xmin}, \code{xmax}, \code{ymin}, \code{ymax} defining the
boundary coordinates of a bounding box.
If provided, only locations within this rectangular area will be returned.
The CRS must be Belgian Lambert 72 (EPSG-code
\href{https://epsg.io/31370}{31370}).}

\item{area_codes}{An optional vector with area codes.
If provided, only locations within the areas will be returned.}

\item{loc_type}{Type of the location (mainly: the type of measurement device).
Defaults to \code{"P"}, i.e. only groundwater piezometers are returned by
default.
Can be a vector with multiple selected values.}

\item{loc_validity}{Validation status of the location.
Can be a vector with multiple selected values, which must belong to
\code{"VLD"}, \code{"ENT"}, \code{"DEL"} or \code{"CLD"}.
Defaults to \code{c("VLD", "ENT")}.}

\item{loc_vec}{An optional vector with location codes.
If provided, only locations are returned that are present in this vector.}

\item{collect}{Should the data be retrieved as a local tibble?
If \code{FALSE} (the default), a \code{tbl_lazy} object is returned
(lazy query).
Hence the result can be further built upon before retrieving data with
\code{\link[dplyr:compute]{collect()}}.}
}
\value{
By default, a \code{tbl_lazy} object.
With \code{collect = TRUE} or with a specified \code{mask},
a local \code{\link[tibble]{tibble}} is returned.

(TO BE ADDED: Explanation on the variable names of the returned object)
}
\description{
Returns locations (and optionally, observation wells) from the \emph{Watina}
database that meet
several criteria (spatial or non-spatial), either as a lazy object or as a
local tibble.
Essential metadata are included in the result.
}
\details{
(TO BE ADDED: Explanation on the different available values of loc_type
and loc_validity)

The lazy object returns a \code{loc_wid} variable, for further use in
\emph{remote} queries.
However, don't use it in local objects: \code{loc_wid} is not to be
regarded as stable.
Therefore, \code{collect = TRUE} does not return \code{loc_wid}.

The result also provides metadata at the level of the observation
well, even when \code{obswells = FALSE}.
In the latter case, this refers to the variables \code{filterdepth} and
\code{soilsurf_ost}, which then
correspond to the most recent observation well
(per location) that meets the criteria on filterdepth.
}
\examples{
\dontrun{
watina <- connect_watina()

get_locs(watina,
         bbox = c(xmin = 1.4e+5,
                  xmax = 1.7e+5,
                  ymin = 1.6e+5,
                  ymax = 1.9e+5))

get_locs(watina,
         area_codes = c("KAL", "KBR"),
         collect = TRUE)

get_locs(watina,
         area_codes = c("KAL", "KBR"),
         loc_type = c("P", "S"),
         collect = TRUE)

# Mark the different output of:
  get_locs(watina,
           loc_vec = c("KBRP081", "KBRP090", "KBRP095", "KBRS001"),
           loc_type = c("P", "S"),
           collect = TRUE)
  # versus:
  get_locs(watina,
           loc_vec = c("KBRP081", "KBRP090", "KBRP095", "KBRS001"),
           collect = TRUE)

# Returning all individual observation wells:
get_locs(watina,
         obswells = TRUE,
         area_codes = c("KAL", "KBR"),
         loc_type = c("P", "S"),
         collect = TRUE)

# Selecting all piezometers with status VLD of the
# province "West-Vlaanderen":
data(BE_ADMIN_PROVINCE,
     package = "BelgiumMaps.StatBel")
library(dplyr)
library(sf)
library(stringr)
mymask <-
    st_as_sf(BE_ADMIN_PROVINCE) \%>\%
    filter(str_detect(TX_PROV_DESCR_NL, "West")) \%>\%
    st_transform(crs = 31370)
get_locs(watina,
         loc_validity = "VLD",
         mask = mymask,
         buffer = 0)

# Disconnect:
DBI::dbDisconnect(watina)
}

}
\seealso{
Other functions to query the database: 
\code{\link{get_chem}()},
\code{\link{get_xg3}()}
}
\concept{functions to query the database}
