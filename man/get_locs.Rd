% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get.R
\name{get_locs}
\alias{get_locs}
\title{Get locations from the database}
\usage{
get_locs(
  con,
  filterdepth_range = c(0, 3),
  filterdepth_guess = FALSE,
  filterdepth_na = FALSE,
  obswells = FALSE,
  obswell_aggr = c("latest", "latest_fd", "latest_sso", "mean"),
  mask = NULL,
  join_mask = FALSE,
  buffer = 10,
  bbox = NULL,
  area_codes = NULL,
  loc_type = c("P", "S", "R", "N", "W", "D", "L", "B"),
  loc_validity = c("VLD", "ENT"),
  loc_vec = NULL,
  collect = FALSE
)
}
\arguments{
\item{con}{A \code{DBIConnection} object to Watina.
See \code{\link{connect_watina}} to generate one.}

\item{filterdepth_range}{Numeric vector of length 2.
Specifies the allowed range of the depth of the filter below soil
surface, as meters (minimum and maximum allowed filterdepth, respectively).
This condition is only applied to groundwater piezometers.
The second vector element cannot be smaller than the first.
Note that 'filterdepth' takes into account \emph{half} the length of the
filter.
It is always assumed that filters are at the bottom of the tube.
Hence
\code{filterdepth = tubelength - filterlength / 2 -
[tubelength part above soil surface]}.
If filterlength is missing, it is assumed to be 0.3 m.
With \code{obswells = FALSE}, a location is kept whenever one observation
well fulfills the condition.}

\item{filterdepth_guess}{Logical.
Only relevant for groundwater piezometers.
Defaults to \code{FALSE}.
For observation wells of which tubelength is known, but not
the part of the tubelength above soil surface (height of measuring point),
filterdepth cannot be calculated and is missing.
However, filterdepth will never be larger than tubelength minus half the
filterlength; hence a maximum
possible (i.e. conservative) value for filterdepth is given by
\code{tubelength - filterlength / 2}.
With \code{filterdepth_guess = TRUE}, filterdepth is replaced by this value
when it cannot be calculated and tubelength is available.
This is done before applying the \code{filterdepth_range} condition.
To mark these cases, a logical variable \code{filterdepth_guessed} is added
to the result: \code{TRUE} for wells where filterdepth was replaced;
\code{FALSE} in all other rows.}

\item{filterdepth_na}{Logical.
Are observation wells with missing filterdepth value to be included?
Defaults to \code{FALSE}.
With \code{filterdepth_guess = TRUE}, this has only effect on the
\emph{remaining} observation wells with missing filterdepth value.}

\item{obswells}{Logical.
If \code{TRUE}, the returned object distinguishes all observation wells
(see \emph{Details}) that
meet the \code{filterdepth_range} condition (or have missing filterdepth, if
\code{filterdepth_na = TRUE}).
If \code{FALSE} (the default), the returned object just distinguishes
locations.
In the latter case, the variables \code{obswell_installdate} and
\code{obswell_stopdate} are not returned.}

\item{obswell_aggr}{String.
Defines how the attributes of multiple observation wells per location that
fulfill the \code{filterdepth_range} and
\code{filterdepth_na} criteria (after filterdepth adjustment if
\code{filterdepth_guess = TRUE}), are
aggregated into one record \strong{per location}:
\itemize{

\item \code{"latest"}: return attributes of the most recent observation well
that fulfills the \code{filterdepth_range} and
\code{filterdepth_na} criteria;

\item \code{"latest_fd"}: return attributes of the most recent observation well
that fulfills the \code{filterdepth_range} condition, i.e.
filterdepth will not be missing unless \emph{all} retained wells have missing
filterdepth \emph{and} \code{filterdepth_na = TRUE};

\item \code{"latest_sso"}: return attributes of the most recent observation well
that fulfills the \code{filterdepth_range} and
\code{filterdepth_na} criteria \emph{and} for which \code{soilsurf_ost}
(soil surface level in the
\href{http://crs.bkg.bund.de/crseu/crs/eu-description.php?crs_id=Y0JFX09PU1QrJTJGK1VOQ09S}{Ostend height}
CRS (EPSG \href{https://epsg.io/5710}{5710}) is not missing (unless
\emph{all} retained wells have missing \code{soilsurf_ost});

\item \code{"mean"}: aggregation not by selecting an individual observation
well, but by averaging the values of the associated variables
\code{soilsurf_ost},
\code{measuringref_ost},
\code{tubelength},
\code{filterlength},
\code{filterdepth}
for the observation wells with non-missing values (different
wells may be involved for each variable, depending on the distribution of
missing values).
With \code{filterdepth_guess = TRUE}, the extra variabele
\code{filterdepth_guessed} is summarised as \code{TRUE} for a location
if at least one of the location's observation wells has
\code{filterdepth_guessed = TRUE}.
}
\strong{In all cases} the returned value of \code{obswell_statecode} and
\code{obswell_state} corresponds to the \code{"latest"} approach.
The \code{obswell_aggr} argument has no effect on locations with a single
retained observation well.
It is ignored if \code{obswells = TRUE}.}

\item{mask}{An optional geospatial filter of class \code{sf}.
If provided, only locations that intersect with \code{mask} will be returned,
with the value of \code{buffer} taken into account.
The CRS must be Belgian Lambert 72 (EPSG-code
\href{https://epsg.io/31370}{31370}).}

\item{join_mask}{Logical.
Do you want to spatially join the attribute columns of \code{mask} to the
resulting tibble?
The spatial join is executed with
\code{\link[sf:geos_binary_pred]{st_intersects()}} as the topological operator.
Beware: if the same location intersects with more than one element of
\code{mask} (taking into account the value of \code{buffer}), that location
will occur multiple times in the result.
\code{join_mask} is ignored if \code{mask} is not provided.}

\item{buffer}{Number of meters taken as a buffer to enlarge
\code{mask} (or shrink it, if \code{buffer < 0}) if \code{mask} is provided.}

\item{bbox}{Optional geospatial fiter (rectangle).
A bounding box (class \code{bbox}), or a vector of four named elements
\code{xmin}, \code{xmax}, \code{ymin}, \code{ymax} defining the
boundary coordinates of a bounding box.
If provided, only locations within this rectangular area will be returned.
The CRS must be Belgian Lambert 72 (EPSG-code
\href{https://epsg.io/31370}{31370}).}

\item{area_codes}{An optional vector with area codes.
If provided, only locations within the areas will be returned.}

\item{loc_type}{Type of the location (mainly: the type of measurement device).
Defaults to \code{"P"}, i.e. only groundwater piezometers are returned by
default.
Can be a vector with multiple selected values.}

\item{loc_validity}{Validation status of the location.
Can be a vector with multiple selected values, which must belong to
\code{"VLD"}, \code{"ENT"}, \code{"DEL"} or \code{"CLD"}.
Defaults to \code{c("VLD", "ENT")}.}

\item{loc_vec}{An optional vector with location codes.
If provided, only locations are returned that are present in this vector.}

\item{collect}{Should the data be retrieved as a local tibble?
If \code{FALSE} (the default), a \code{tbl_lazy} object is returned
(lazy query).
Hence the result can be further built upon before retrieving data with
\code{\link[dplyr:compute]{collect()}}.}
}
\value{
By default, a \code{tbl_lazy} object.
With \code{collect = TRUE} or with a specified \code{mask},
a local \code{\link[tibble]{tibble}} is returned.

(TO BE ADDED: Explanation on the variable names of the returned object)
}
\description{
Returns locations (and optionally, observation wells) from the \emph{Watina}
database that meet
several criteria, either as a lazy object or as a
local tibble.
Criteria refer to spatial or non-spatial physical attributes of the
location or the location's observation wells.
Essential metadata are included in the result.
}
\details{
(TO BE ADDED: Explanation on the different available values of loc_type
and loc_validity)

The lazy object returns a \code{loc_wid} variable, for further use in
\emph{remote} queries.
However, don't use it in local objects: \code{loc_wid} is not to be
regarded as stable.
Therefore, \code{collect = TRUE} does not return \code{loc_wid}.

The result also provides metadata at the level of the observation
well, even when \code{obswells = FALSE}.
In the latter case, this refers to the variables
\code{soilsurf_ost},
\code{measuringref_ost},
\code{tubelength},
\code{filterlength},
\code{filterdepth}.
See the argument \code{obswell_aggr} for options of how to aggregate this
information at the location level;
by default the latest observation well is used
(per location) that meets the criteria on filterdepth.
Mind that \code{obswells = FALSE} and \code{filterdepth_na = TRUE} may lead
to missing filterdepth values at locations which do have a
value for an older observation well, but not for the most recent one.

Please note the meaning of observation well in Watina: if there are multiple
observation wells attached to one location, these belong to
\emph{other timeframes}!
So one location always coincides with exactly one observation well at
one moment in time.
Multiple observation wells can succeed one another because of physical
alterations (e.g. damage of a piezometer).
Here, the term 'observation well' is used to refer to a fixed installed
device in the field (groundwater piezometer, surface water level
measurement device).
}
\note{
Up to and including \verb{watina 0.3.0}, the result was sorted according to
\code{area_code} and \code{loc_code},
both for the lazy query and the collected result.
Later versions avoid sorting in case of a lazy result, because
otherwise, when using the result inside another lazy query, this led to
'ORDER BY' constructs in SQL subqueries, which must be avoided.
If you like to print the lazy object in a sorted manner, you must add
\verb{\%>\% arrange(...)} yourself.
}
\examples{
\dontrun{
watina <- connect_watina()

library(dplyr)

get_locs(watina,
         bbox = c(xmin = 1.4e+5,
                  xmax = 1.7e+5,
                  ymin = 1.6e+5,
                  ymax = 1.9e+5)) \%>\%
    arrange(area_code, loc_code)

get_locs(watina,
         area_codes = c("KAL", "KBR"),
         collect = TRUE)

get_locs(watina,
         area_codes = c("KAL", "KBR"),
         loc_type = c("P", "S"),
         collect = TRUE)

get_locs(watina,
         area_codes = "WES") \%>\%
    count()

get_locs(watina,
         area_codes = "WES",
         filterdepth_guess = TRUE) \%>\%
    count()

get_locs(watina,
         area_codes = c("KAL", "KBR"),
         loc_type = c("P", "S"),
         filterdepth_na = TRUE,
         collect = TRUE)

# Mark the different output of:
  get_locs(watina,
           loc_vec = c("KBRP081", "KBRP090", "KBRP095", "KBRS001"),
           loc_type = c("P", "S"),
           collect = TRUE)
  # versus:
  get_locs(watina,
           loc_vec = c("KBRP081", "KBRP090", "KBRP095", "KBRS001"),
           collect = TRUE)

# Returning all individual observation wells:
get_locs(watina,
         obswells = TRUE,
         area_codes = c("KAL", "KBR"),
         loc_type = c("P", "S"),
         collect = TRUE)

# Different examples of aggregating observation wells at location level:
get_locs(watina,
         area_codes = "WES",
         filterdepth_na = TRUE,
         filterdepth_guess = TRUE,
         obswell_aggr = "latest",
         collect = TRUE) \%>\%
    select(loc_code, contains("ost"), contains("filterdepth")) \%>\%
    head(12)

get_locs(watina,
         area_codes = "WES",
         filterdepth_na = TRUE,
         filterdepth_guess = TRUE,
         obswell_aggr = "mean",
         collect = TRUE) \%>\%
    select(loc_code, contains("ost"), contains("filterdepth")) \%>\%
    head(12)

# Selecting all piezometers with status VLD of the
# province "West-Vlaanderen" (current polygon taken
# from the official WFS service):
library(sf)
library(purrr)
library(httr)
mymask <-
    "https://geoservices.informatievlaanderen.be/overdrachtdiensten/VRBG/wfs" \%>\%
    parse_url() \%>\%
    list_merge(query = list(request = "GetFeature",
                            typeName = "VRBG:Refprv",
                            cql_filter="NAAM='West-Vlaanderen'",
                            srsName = "EPSG:31370",
                            outputFormat = "text/xml; subtype=gml/3.1.1")) \%>\%
    build_url() \%>\%
    read_sf(crs = 31370) \%>\%
    st_cast("GEOMETRYCOLLECTION")
get_locs(watina,
         loc_validity = "VLD",
         mask = mymask,
         buffer = 0)

# Disconnect:
dbDisconnect(watina)
}

}
\seealso{
Other functions to query the database: 
\code{\link{get_chem}()},
\code{\link{get_xg3}()}
}
\concept{functions to query the database}
