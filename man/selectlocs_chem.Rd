% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/selectlocs.R
\name{selectlocs_chem}
\alias{selectlocs_chem}
\title{Select locations based on hydrochemical data properties}
\usage{
selectlocs_chem(
  data,
  data_type = c("data", "summary"),
  chem_var = c("P-PO4", "N-NO3", "N-NO2", "N-NH4", "HCO3", "SO4", "Cl", "Na", "K",
    "Ca", "Mg", "Fe", "Mn", "Si", "Al", "CondF", "CondL", "pHF", "pHL"),
  conditions,
  verbose = TRUE,
  list = FALSE
)
}
\arguments{
\item{data}{An object as returned by either \code{\link{get_chem}}
(the object corresponds to real 'data') or
\code{\link{eval_chem}} (the object contains summary values).}

\item{data_type}{A string.
Either \code{"data"} (the default) or \code{"summary"}, in correspondence
with the choice made for \code{data}.}

\item{chem_var}{Only relevant
when data is an object formatted as returned by
\code{\link{get_chem}}.
Is a character vector to select chemical variables for which
statistics will be computed.
To specify chemical variables, use the
codes from the column \code{chem_variable} in \code{data}.
Together with the available variables in \code{data},
\code{chem_var} determines the meaning of the variable \code{"combined"}.}

\item{conditions}{A dataframe.
See the devoted section below.}

\item{verbose}{Logical.
If \code{TRUE}, give feedback on dropped locations because of
(specific) unused conditions and other 'mismatch' reasons.}

\item{list}{Logical.
If \code{FALSE} (the default), the function only returns the end-result
(a tibble with selected location codes).
If \code{TRUE}, the function returns a list with the end-result plus useful
intermediate results (see Value).}
}
\value{
If \code{list = FALSE}: a tibble with one column \code{loc_code} that
provides the locations selected by the conditions.

If \code{list = TRUE}: a list of tibbles that extends the previous end-result
with intermediate results.
All list elements are named:
\enumerate{
\item{\code{combined_result_filtered}}:
the end-result, same as given by \code{list = FALSE}.

\item{\code{result}}:
the test result of
each computed and tested statistic for each location and
chemical variable: 'condition met' (\code{cond_met}) is TRUE or FALSE.

\item{\code{combined_result}}:
aggregation of \code{result} \strong{per location}.
Specific columns:
\code{all_cond_met} is \code{TRUE} if \emph{all} conditions
for that location were \code{TRUE}, and is \code{FALSE} in all other cases.
\code{pct_cond_met} is the percentage of 'met' availability conditions
per location.
}
}
\description{
Select locations that comply with user-specified conditions,
from a dataset as returned by either \code{\link{get_chem}} or
\code{\link{eval_chem}}.
Conditions can be specified for each of the summary statistics returned
by \code{\link{eval_chem}}.
}
\details{
\code{selectlocs_chem()} separately runs \code{eval_chem} on the input
(\code{data}) if \code{data_type = "data"}.
See the documentation of
\code{\link{eval_chem}}
to learn more about the available summary statistics.
Each condition for evaluation + selection of locations
is specific to a chemical \emph{variable}, which can also be
the level 'combined'.
Hence, the result will depend both on the \emph{chemical variables} for
which statistics have been computed (specified by \code{chem_var}),
and on the conditions, specified by \code{conditions}.
See the devoted section on the \code{conditions} dataframe.

Only locations are returned:
\itemize{
\item{
which have \strong{all} chemical variables, implied by
\code{chem_var} and present in \code{conditions}, available in \code{data}.
(In other words, all conditions must be testable.)
}
\item{
for which \strong{all}
conditions are met;
}
}
As the conditions imposed by the \code{conditions} dataframe are always
evaluated as a
required combination of conditions ('and'), the user must make different
calls to \code{selectlocs_chem()}
if different sets of conditions are to be allowed ('or').

If \code{data_type = "data"}, \code{selectlocs_chem()} calls
\code{\link{eval_chem}}.
Its \code{type} and \code{uniformity_test} arguments are derived from the
user-specified \code{conditions} dataframe.

\code{selectlocs_chem()} joins the long-formatted results of
\code{\link{eval_chem}}
with the \code{conditions} dataframe in order to evaluate the conditions.
Often, this join in itself already leads to dropping specific
combinations of \code{loc_code} and \code{chem_variable}.
At least the locations that are completely dropped in this step are reported
when \code{verbose = TRUE}.

The user may want to repeatedly try different sets of conditions
until a satisfying selection of locations is returned.
However the output of \code{\link{eval_chem}}
will not change as long as the data are not altered.
For that reason, the user can also feed the
result of \code{eval_chem()} to the \code{data} argument,
with \code{data_type = "summary"}.
In that case the argument \code{chem_var} is ignored.
}
\section{Specification of the conditions dataframe}{

Conditions can be specified for each of the summary statistics returned
by \code{\link{eval_chem}}.

The \code{conditions} parameter takes a dataframe that must have the
following columns:
\describe{
\item{\code{chem_variable}}{Can be any chemical variable code,
including \code{"combined"}.}
\item{\code{statistic}}{Name of the statistic to be evaluated.}
\item{\code{criterion}}{Numeric. Defines the value of the statistic on which
the
condition will be based.

For condition testing on statistics of type 'date', provide the numeric date
representation, i.e. the number of days since 1 Jan 1970 (older dates are
negative).
This can be easily calculated for a given '\code{datestring}'
(e.g. "18-5-2020") with:
\code{as.numeric(lubridate::dmy(datestring))}.}
\item{\code{direction}}{One of: \code{"min","max","equal"}.
Together with \code{criterion}, this completes the condition which will
be evaluated with respect to the specific \code{chem_variable}:
for \code{direction = "min"}, the statistic must be the criterion
value or larger; for \code{direction = "max"}, the statistic must be
the criterion value or lower; for \code{direction = "equal"},
the statistic must be equal to the criterion value.
}
}

Each condition is one row of the dataframe.
The dataframe should have at least one, and may have many.
Each combination of \code{chem_variable} and \code{statistic} must be
unique.
Conditions on chemical variables, absent from \code{data} or not implied by
\code{chem_var}, will be dropped without warning.
Hence, it is up to the user to do sensible things.

The possible statistics for conditions on chemical variables are documented
by \code{\link{eval_chem}}.
}

\examples{
\dontrun{
watina <- connect_watina()
library(dplyr)
mylocs <- get_locs(watina, area_codes = "ZWA")
mydata <-
    mylocs \%>\%
    get_chem(watina, "1/1/2010")
mydata \%>\% arrange(loc_code, date, chem_variable)
mydata \%>\%
    pull(date) \%>\%
    lubridate::year(.) \%>\%
    (function(x) c(firstyear = min(x), lastyear = max(x)))

## EXAMPLE 1
# to prepare a condition on 'firstdate', we need its numerical value:
as.numeric(lubridate::dmy("1/1/2014"))
conditions_df <-
    tribble(
        ~chem_variable, ~statistic, ~criterion, ~direction,
        "N-NO3", "nrdates", 2, "min",
        "P-PO4", "nrdates", 2, "min",
        "P-PO4", "firstdate", 16071, "max",
        "P-PO4", "timespan_years", 5, "min"
    )
conditions_df
myresult <-
    mydata \%>\%
    selectlocs_chem(data_type = "data",
                    chem_var = c("N-NO3", "P-PO4"),
                    conditions = conditions_df,
                    list = TRUE)
myresult
# or:
# mystats <- eval_chem(mydata, chem_var = c("N-NO3", "P-PO4"))
# myresult <-
#   mystats \%>\%
#   selectlocs_chem(data_type = "summary",
#                   conditions = conditions_df,
#                   list = TRUE)
myresult$combined_result_filtered

## EXAMPLE 2
# An example based on numeric statistics:
conditions_df <-
    tribble(
        ~chem_variable, ~statistic, ~criterion, ~direction,
        "pHF", "val_mean", 5, "max",
        "CondF", "val_pct50", 100, "min"
    )
conditions_df
mydata \%>\%
    selectlocs_chem(data_type = "data",
                    chem_var = c("pHF", "CondF"),
                    conditions = conditions_df)

# Disconnect:
DBI::dbDisconnect(watina)
}

}
\seealso{
\code{\link{eval_chem}}

Other functions to select locations: 
\code{\link{selectlocs_xg3}()}
}
\concept{functions to select locations}
