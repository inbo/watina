% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/selectlocs.R
\name{selectlocs_xg3}
\alias{selectlocs_xg3}
\title{Select locations based on XG3 availability and XG3 series' properties}
\usage{
selectlocs_xg3(data, xg3_type = NULL, max_gap = NULL, min_dur = NULL,
  conditions, verbose = TRUE, list = FALSE)
}
\arguments{
\item{data}{Either an object returned by \code{\link{get_xg3}},
or a named list of two tibbles: \code{"avail"} and \code{"ser"}.
In the latter case, \code{"avail"} must be the output of
\code{\link{eval_xg3_avail}} and \code{"ser"} must be the output of
\code{\link{eval_xg3_series}}, whereby each function was applied to the same
dataset and used the same setting for the \code{xg3_type} argument.
See Details.}

\item{xg3_type}{Only relevant
when data is an object formatted as returned by
\code{\link{get_xg3}}.
In that case, must be a character vector of length 1, 2 or 3,
which will default to \code{"L"} if not specified.
Defines the types of XG3 which are taken from \code{data}.
Specifies the 'X' in 'XG3': either \code{"L"}, \code{"H"} and/or \code{"V"}.}

\item{max_gap}{A positive integer (can be zero).
It is part of what the user defines as 'an XG3 series':
the maximum allowed time gap between two consecutive
XG3 values in a series, expressed as the number of years without XG3 value.}

\item{min_dur}{A strictly positive integer.
It is part of what the user defines as 'an XG3 series':
the minimum required duration of an XG3 series,
i.e. the time (expressed as years)
from the first to the last year of the XG3 series.}

\item{conditions}{A dataframe.
See the devoted section below.}

\item{verbose}{Logical.
If \code{TRUE}, give feedback on dropped locations because of
(specific) unused conditions and other 'mismatch' reasons.}

\item{list}{Logical.
If \code{FALSE} (the default), the function only returns the end-result
(a tibble with selected location codes).
If \code{TRUE}, the function returns a list with the end-result plus useful
intermediate results (see Value).}
}
\value{
If \code{list = FALSE}: a tibble with one column \code{loc_code} that
provides the locations selected by the conditions.

If \code{list = TRUE}: a list of tibbles that extends the previous end-result
with intermediate results.
The below elements nrs. 2 and 3 are only given when at least one XG3
availability
condition was given, nrs. 4, 5 and 6 only when at least one XG3 series
condition was given,
and nr. 7 is only returned when both types of condition were given.
All list elements are named:
\enumerate{
\item{\code{combined_result_filtered}}:
the end-result, same as given by \code{list = FALSE}.

\item{\code{result_avail}}:
the test result of
each computed and tested \emph{availability} statistic for each location and
XG3 variable: 'condition met' (\code{cond_met}) is TRUE or FALSE.

\item{\code{combined_result_avail}}:
aggregation of \code{result_avail} \strong{per location}.
Specific columns:
\code{cond_met_avail} is \code{TRUE} if \emph{all} availability conditions
for that location were \code{TRUE}, and is \code{FALSE} in all other cases.
\code{pct_cond_met_avail} is the percentage of 'met' availability conditions
per location.

\item{\code{result_series}}:
the test result of
each computed and tested \emph{series} statistic for each location and
XG3 series: 'condition met' (\code{cond_met}) is TRUE or FALSE.

\item{\code{combined_result_series_xg3var}}:
aggregation of \code{result_series} \strong{per location and XG3 variable}.
Two consecutive aggregation steps are involved here:
\enumerate{
\item{per XG3 series: are \emph{all} series conditions met?}
\item{per XG3 variable: is there \emph{at least one} series where all series
conditions are met?}
}
Specific columns:
\code{all_ser_cond_met_xg3var} is the answer to question 2 (TRUE/FALSE).
\code{avg_pct_cond_met_nonpassed_series} is the average percentage
(for a location and XG3 variable) of 'met'
series conditions in the series where \emph{not} all conditions were met.
(Note that the same percentage is 100 for series where all conditions are
met, leading to \code{all_ser_cond_met_xg3var = TRUE} at the level of
location and XG3 variable.)

\item{\code{combined_result_series}}:
aggregation of \code{combined_result_series_xg3var} \strong{per location}.
Specific columns:
\code{cond_met_series} is \code{TRUE} if \emph{all} XG3 variables
(that have series and on which series conditions were imposed)
were \code{TRUE} in the previous aggregation
(\code{all_ser_cond_met_xg3var = TRUE}), and is \code{FALSE} in all other
cases.
\code{pct_xg3vars_passed_ser} is the percentage of a location's XG3 variables
(that have series and on which series conditions were imposed) that were
\code{TRUE} in the previous aggregation
(\code{all_ser_cond_met_xg3var = TRUE}).
\code{avg_pct_cond_met_in_nonpassed_series} is the average of
\code{avg_pct_cond_met_nonpassed_series} from the previous aggregation step,
over the involved XG3 variables at the location.

\item{\code{combined_result}}:
the inner join (on \code{loc_code}) between \code{combined_result_avail}
and \code{combined_result_series}.
Locations that were dropped in either evaluation because of missing
information, are dropped here too,
because the function is to return locations for which all conditions hold
and hence could be verified.

The last column, \code{all_cond_met}, requires both
\code{cond_met_avail = TRUE} and \code{cond_met_series = TRUE} to result in
\code{TRUE} for a location.

Notes:
\itemize{
\item{locations with \code{all_cond_met = FALSE} are not discarded in this
object;}
\item{filtering locations with \code{all_cond_met = TRUE} will result in
exactly
the locations given by \code{combined_result_filtered}, see list element 1;}
\item{the object is only returned when both availability and series
condition(s) were given (at least one of each family).
In the other cases, you can directly look at \code{combined_result_avail}
or \code{combined_result_series}, from which \code{combined_result_filtered}
is derived.}
}
}
}
\description{
Select locations that comply with user-specified conditions,
from a dataset as returned by \code{\link{get_xg3}},
\emph{or} from a list with the outputs of
\code{\link{eval_xg3_avail}} and \code{\link{eval_xg3_series}}.
Conditions can be specified for each of the summary statistics returned
by \code{\link{eval_xg3_avail}} and \code{\link{eval_xg3_series}}.
}
\details{
\code{selectlocs_xg3()} separately runs \code{eval_xg3_avail()} and
\code{eval_xg3_series()} on the input (\code{data}) if the latter
conforms to the output of \code{\link{get_xg3}}.
See the documentation of
\code{\link{eval_xg3_avail}} and \code{\link{eval_xg3_series}}
to learn more about how an 'XG3 variable'
and an 'XG3 series' are defined, and about the available summary statistics.
Each condition for evaluation + selection of locations
is specific to an XG3 \emph{variable}, which can also be
the level 'combined'.
Hence, the result will depend both on the XG3 \emph{types} (HG3, LG3 and/or
VG3) for which statistics have been computed (specified by \code{xg3_type}),
and on the conditions, specified by \code{conditions}.
See the devoted section on the \code{conditions} dataframe.

Only locations are returned:
\itemize{
\item{
for which \strong{all}
conditions are met, i.e. for the XG3 variables implied by \code{xg3_type}
and which occur in \code{conditions};
}
\item{
which have at least one such XG3 variable available in \code{data}.
}
}
As the conditions imposed by the \code{conditions} dataframe are always
evaluated as a
required combination of conditions ('and'), the user must make different
calls to \code{selectlocs_xg3()}
if different sets of conditions are to be allowed ('or').

Regarding conditions that evaluate XG3 \emph{series}, it is taken into
account that one location can have multiple series for the same XG3
variable.
When the user provides one or more conditions for the series of a specific
XG3 variable, the condition(s) are regarded as fulfilled ('condition met')
when \strong{at least one} series is present of that XG3 variable
for which \strong{all} those conditions are met.

\code{selectlocs_xg3()} joins the long-formatted results of
\code{\link{eval_xg3_avail}} and \code{\link{eval_xg3_series}}
with the \code{conditions} dataframe in order to evaluate the conditions.
Often, this (inner) join in itself already leads to dropping specific
combinations of \code{loc_code} and \code{xg3_variable}.
At least the locations that are completely dropped in this step are reported
when \code{verbose = TRUE}.

For larger datasets \code{eval_xg3_series()} can take quite some time,
whereas the user may want to repeatedly try different sets of conditions
until a satisfying selection of locations is returned.
However the output of both \code{eval_xg3_avail()} and
\code{eval_xg3_series()} will not change as long as the data and the chosen
values of \code{max_gap} and \code{min_dur} are not altered.
For that reason, the user can also prepare a list object with the
respective results of \code{eval_xg3_avail()} and \code{eval_xg3_series()},
which must be named as \code{"avail"} and \code{"ser"}, respectively.
This list can instead be used as data-input, and in that case
\code{xg3_type}, \code{max_gap} and \code{min_dur} are not needed
(they will be ignored).
}
\section{Specification of the conditions dataframe}{

Conditions can be specified for each of the summary statistics returned
by \code{\link{eval_xg3_avail}} and \code{\link{eval_xg3_series}}.
Consequently, XG3 availability conditions and
XG3 series conditions can be distinguished.

The \code{conditions} parameter takes a dataframe that must have the
following columns:
\describe{
\item{\code{xg3_variable}}{One of: \code{"combined","lg3_lcl","lg3_ost",
"vg3_lcl",
"vg3_ost","hg3_lcl","hg3_ost"}.}
\item{\code{statistic}}{Name of the statistic to be evaluated.}
\item{\code{criterion}}{Numeric. Defines the value of the statistic on which
the
condition will be based.}
\item{\code{direction}}{One of: \code{"min","max","equal"}.
Together with \code{criterion}, this completes the condition which will
be evaluated with respect to the specific \code{xg3_variable}:
for \code{direction = "min"}, the statistic must be the criterion
value or larger; for \code{direction = "max"}, the statistic must be
the criterion value or lower; for \code{direction = "equal"},
the statistic must be equal to the criterion value.
}
}

Each condition is one row of the dataframe.
The dataframe should have at least one, and may have many.
Each combination of \code{xg3_variable} and \code{statistic} must be
unique.
Conditions on XG3 variables, absent from \code{data} or not implied by
\code{xg3_type}, will be dropped without warning.
Hence, it is up to the user to do sensible things.

The possible statistics for XG3 availability conditions are: \emph{nryears,
firstyear, lastyear}.

The possible statistics for XG3 series conditions are: \emph{ser_length,
ser_nryears, ser_rel_nryears, ser_firstyear, ser_lastyear,
ser_pval_uniform, ser_mean, ser_sd, ser_se_6y, ser_rel_sd_lcl,
ser_rel_se_6y_lcl}. The last six are not defined for the XG3 variable
'combined', and the last two are only defined for variables with a local
vertical CRS.
}

\examples{
\dontrun{
watina <- connect_watina()
library(dplyr)
mylocs <- get_locs(watina,
                   area_codes = "TOR",
                   loc_type = c("P", "S"))
mydata <-
 mylocs \%>\%
 get_xg3(watina, 2000)
mydata
# Number of locations in mydata:
mydata \%>\% distinct(loc_code) \%>\% count
# Number of hydrological years per location and XG3 variable:
mydata \%>\%
  group_by(loc_code) \%>\%
  collect \%>\%
  summarise(lg3_lcl = sum(!is.na(lg3_lcl)),
            hg3_lcl = sum(!is.na(hg3_lcl)),
            vg3_lcl = sum(!is.na(vg3_lcl)))
conditions_df <-
  tribble(
  ~xg3_variable, ~statistic, ~criterion, ~direction,
  "lg3_lcl", "ser_lastyear", 2015, "min",
  "hg3_lcl", "ser_lastyear", 2015, "min"
  )
conditions_df
result <-
  mydata \%>\%
  selectlocs_xg3(xg3_type = c("L", "H"),
                  max_gap = 1,
                  min_dur = 5,
                  conditions = conditions_df,
                  list = TRUE)
# or:
# mystats <- list(avail = eval_xg3_avail(mydata,
#                                        xg3_type = c("L", "H")),
#                 ser =  eval_xg3_series(mydata,
#                                        xg3_type = c("L", "H"),
#                                        max_gap = 1,
#                                        min_dur = 5))
# result <-
#   mystats \%>\%
#   selectlocs_xg3(conditions = conditions_df,
#                  list = TRUE)
result$combined_result_filtered
result[2:4]
# Disconnect:
DBI::dbDisconnect(watina)
}

}
\seealso{
\code{\link{eval_xg3_avail}}, \code{\link{eval_xg3_series}}

Other functions to select locations: \code{\link{selectlocs_chem}}
}
\concept{functions to select locations}
