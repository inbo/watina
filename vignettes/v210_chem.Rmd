---
title: "Using hydrochemical data to characterize and select locations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using hydrochemical data to characterize and select locations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
library(watina)
library(sf)
library(dplyr)
library(stringr)
library(knitr)
```

_General note: the below vignette contains frozen output of 16 Sep 2019._
_This makes it possible to build the package with vignettes without access to the Watina database._

## Overview

Let's have a look at how chemical data, retrieved from Watina, look like.
The below example requests available hydrochemical data since 2010 from locations in the area 'Zwarte Beek':

```{r}
watina <- connect_watina()
mydata <-
    get_locs(watina, area_codes = "ZWA") %>% 
    get_chem(watina, "1/1/2010")
mydata %>% 
  count
#> # Source:   lazy query [?? x 1]
#> # Database: Microsoft SQL Server
#>       n
#>   <int>
#> 1  1427
class(mydata)
#> [1] "tbl_Microsoft SQL Server" "tbl_dbi"                 
#> [3] "tbl_sql"                  "tbl_lazy"                
#> [5] "tbl"
mydata %>% 
  head(15) %>% 
  collect %>% 
  as.data.frame
#>    loc_code       date lab_project_id lab_sample_id chem_variable   value
#> 1   ZWAP033 2013-10-22              0         38037            Ca  20.230
#> 2   ZWAP033 2013-10-22              0         38037            Cl  30.600
#> 3   ZWAP033 2013-10-22              0         38037         CondF 426.000
#> 4   ZWAP033 2013-10-22              0         38037         CondL 425.400
#> 5   ZWAP033 2013-10-22              0         38037            Fe  60.300
#> 6   ZWAP033 2013-10-22              0         38037          HCO3   2.900
#> 7   ZWAP033 2013-10-22              0         38037             K   7.400
#> 8   ZWAP033 2013-10-22              0         38037            Mg   7.600
#> 9   ZWAP033 2013-10-22              0         38037            Na   5.590
#> 10  ZWAP033 2013-10-22              0         38037         N-NH4   0.197
#> 11  ZWAP033 2013-10-22              0         38037         N-NO2   0.015
#> 12  ZWAP033 2013-10-22              0         38037         N-NO3   0.054
#> 13  ZWAP033 2013-10-22              0         38037           pHF   5.660
#> 14  ZWAP033 2013-10-22              0         38037           pHL   4.780
#> 15  ZWAP033 2013-10-22              0         38037         P-PO4   0.015
#>    units below_loq loq  elneutr
#> 1   mg/l        NA -99 0.056614
#> 2   mg/l        NA -99 0.056614
#> 3  µS/cm        NA -99 0.056614
#> 4  µS/cm        NA -99 0.056614
#> 5   mg/l        NA -99 0.056614
#> 6   mg/l        NA -99 0.056614
#> 7   mg/l        NA -99 0.056614
#> 8   mg/l        NA -99 0.056614
#> 9   mg/l        NA -99 0.056614
#> 10  mg/l        NA -99 0.056614
#> 11  mg/l        NA -99 0.056614
#> 12  mg/l        NA -99 0.056614
#> 13  <NA>        NA -99 0.056614
#> 14  <NA>        NA -99 0.056614
#> 15  mg/l        NA -99 0.056614
```

The first and last year of the dataset are:

```{r}
mydata %>%
    pull(date) %>%
    lubridate::year(.) %>%
    (function(x) c(firstyear = min(x), lastyear = max(x)))
#> firstyear  lastyear 
#>      2011      2019
```

Let's suppose that we now want to select locations for which:

- both N-NO3 (nitrate nitrogen) and P-PO4 (orthophosphate phosphorus) have at least two measurement dates;
- the first date of P-PO4 is not later than 1/1/2014;
- the first and last year with P-PO4 data are at least 4 years apart, i.e. they span at least 5 calendar years

To express criteria, we need the numerical value of a date:

```{r}
as.numeric(lubridate::dmy("1/1/2014"))
#> [1] 16071
```

We can store specific conditions in a dataframe; the available statistics are explained by the documentation of `eval_chem()`:

```{r eval=TRUE}
conditions_df <-
    tribble(
        ~chem_variable, ~statistic, ~criterion, ~direction,
        "N-NO3", "nrdates", 2, "min",
        "P-PO4", "nrdates", 2, "min",
        "P-PO4", "firstdate", 16071, "max",
        "P-PO4", "timespan_years", 5, "min"
    )
conditions_df %>% 
  kable
```

You can also separately limit the chemical variables to be evaluated with the `chem_var` argument in the `selectlocs_chem()` function:

```{r}
myresult <-
    mydata %>%
    selectlocs_chem(data_type = "data",
                    chem_var = c("N-NO3", "P-PO4"),
                    conditions = conditions_df)
myresult
#> # A tibble: 9 x 1
#>   loc_code
#>   <chr>   
#> 1 ZWAP051 
#> 2 ZWAP064 
#> 3 ZWAP067 
#> 4 ZWAP129 
#> 5 ZWAP196 
#> 6 ZWAP205 
#> 7 ZWAP214 
#> 8 ZWAP215 
#> 9 ZWAP220
```

With the argument `list = TRUE` you can also obtain intermediate test results.
For further information, see the documentation of the `selectlocs_chem()` function.


## The basics: obtaining hydrochemical data

The `get_chem()` function in the above example retrieved hydrochemical data, from given locations, as a lazy object (unless `collect = TRUE`).
A timeframe is used to filter hydrochemical data in Watina (with arguments `startdate` and `enddate`).
By default, the `enddate` argument is set as _today_.
Here we only provide the `startdate`:

```{r}
mylocs <- get_locs(watina, area_codes = "ZWA")
mylocs %>% get_chem(watina, "1/1/2017")
#> # Source:     lazy query [?? x 10]
#> # Database:   Microsoft SQL Server
#> # Ordered by: area_code, loc_code, loc_code, date, chem_variable
#>    loc_code date       lab_project_id lab_sample_id chem_variable   value
#>    <chr>    <date>     <chr>          <chr>         <chr>           <dbl>
#>  1 ZWAP051  2018-10-29 0              40080         Al              0.05 
#>  2 ZWAP051  2018-10-29 0              40080         Ca             24.8  
#>  3 ZWAP051  2018-10-29 0              40080         Cl             36.7  
#>  4 ZWAP051  2018-10-29 0              40080         CondF         223    
#>  5 ZWAP051  2018-10-29 0              40080         CondL         224.   
#>  6 ZWAP051  2018-10-29 0              40080         Fe              0.782
#>  7 ZWAP051  2018-10-29 0              40080         HCO3            8.89 
#>  8 ZWAP051  2018-10-29 0              40080         K               1.68 
#>  9 ZWAP051  2018-10-29 0              40080         Mg              2.73 
#> 10 ZWAP051  2018-10-29 0              40080         Mn              0.149
#> # … with more rows, and 4 more variables: units <chr>, below_loq <lgl>,
#> #   loq <dbl>, elneutr <dbl>
```

Retrieving the data locally:

```{r}
mylocs %>% get_chem(watina, "1/1/2017", collect = TRUE)
#> # A tibble: 493 x 10
#>    loc_code date       lab_project_id lab_sample_id chem_variable   value
#>    <chr>    <date>     <chr>          <chr>         <chr>           <dbl>
#>  1 ZWAP051  2018-10-29 0              40080         Al              0.05 
#>  2 ZWAP051  2018-10-29 0              40080         Ca             24.8  
#>  3 ZWAP051  2018-10-29 0              40080         Cl             36.7  
#>  4 ZWAP051  2018-10-29 0              40080         CondF         223    
#>  5 ZWAP051  2018-10-29 0              40080         CondL         224.   
#>  6 ZWAP051  2018-10-29 0              40080         Fe              0.782
#>  7 ZWAP051  2018-10-29 0              40080         HCO3            8.89 
#>  8 ZWAP051  2018-10-29 0              40080         K               1.68 
#>  9 ZWAP051  2018-10-29 0              40080         Mg              2.73 
#> 10 ZWAP051  2018-10-29 0              40080         Mn              0.149
#> # … with 483 more rows, and 4 more variables: units <chr>,
#> #   below_loq <lgl>, loq <dbl>, elneutr <dbl>
```

Note below, the different number of results when using non-default settings for filtering according to _electroneutrality_!
The default range of electroneutrality is from -0.1 to 0.1 (argument `en_range`).

```{r}
mylocs %>% get_chem(watina, "1/1/2017") %>% count
#> # Source:   lazy query [?? x 1]
#> # Database: Microsoft SQL Server
#>       n
#>   <int>
#> 1   493
mylocs %>% get_chem(watina, "1/1/2017", exclude_en_na = TRUE) %>% count
#> # Source:   lazy query [?? x 1]
#> # Database: Microsoft SQL Server
#>       n
#>   <int>
#> 1   481
mylocs %>% get_chem(watina, "1/1/2017", en_range = c(-1, 1)) %>% count
#> # Source:   lazy query [?? x 1]
#> # Database: Microsoft SQL Server
#>       n
#>   <int>
#> 1   674
```

With `exclude_en_na = TRUE`, samples for which no electroneutrality could be calculated are discarded!

Equivalence concentrations instead of mass concentrations can be returned with `conc_type = "eq"`:

```{r}
mylocs %>% get_chem(watina, "1/1/2017", conc_type = "eq")
#> # Source:     lazy query [?? x 10]
#> # Database:   Microsoft SQL Server
#> # Ordered by: area_code, loc_code, loc_code, date, chem_variable
#>    loc_code date       lab_project_id lab_sample_id chem_variable   value
#>    <chr>    <date>     <chr>          <chr>         <chr>           <dbl>
#>  1 ZWAP051  2018-10-29 0              40080         Al            5.00e-2
#>  2 ZWAP051  2018-10-29 0              40080         Ca            1.24e+0
#>  3 ZWAP051  2018-10-29 0              40080         Cl            1.03e+0
#>  4 ZWAP051  2018-10-29 0              40080         CondF         2.23e+2
#>  5 ZWAP051  2018-10-29 0              40080         CondL         2.24e+2
#>  6 ZWAP051  2018-10-29 0              40080         Fe            2.80e-2
#>  7 ZWAP051  2018-10-29 0              40080         HCO3          1.46e-1
#>  8 ZWAP051  2018-10-29 0              40080         K             4.30e-2
#>  9 ZWAP051  2018-10-29 0              40080         Mg            2.25e-1
#> 10 ZWAP051  2018-10-29 0              40080         Mn            1.49e-1
#> # … with more rows, and 4 more variables: units <chr>, below_loq <lgl>,
#> #   loq <dbl>, elneutr <dbl>
```

Joining results to `mylocs`:

```{r}
mylocs %>%
get_chem(watina, "1/1/2017") %>%
    left_join(mylocs %>%
                  select(-loc_wid),
              .) %>%
    collect
#> Joining, by = "loc_code"
#> # A tibble: 659 x 18
#>    loc_code area_code area_name      x      y loc_validitycode loc_validity
#>    <chr>    <chr>     <chr>      <dbl>  <dbl> <chr>            <chr>       
#>  1 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  2 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  3 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  4 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  5 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  6 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  7 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  8 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#>  9 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#> 10 ZWAP502  ZWA       Zwarte B… 222460 199240 VLD              Gevalideerd 
#> # … with 649 more rows, and 11 more variables: loc_typecode <chr>,
#> #   loc_typename <chr>, date <date>, lab_project_id <chr>,
#> #   lab_sample_id <chr>, chem_variable <chr>, value <dbl>, units <chr>,
#> #   below_loq <lgl>, loq <dbl>, elneutr <dbl>
```


## Processing hydrochemical data and selecting locations

You can characterize the locations of a dataset of hydrochemical data, using the `eval_chem()` function.
You are invited to read its documentation and try its examples!

The `selectlocs_chem()` function, of which we saw a demonstration above, calls `eval_chem()` by itself.
Alternatively the user can provide the result of those functions as input to `selectlocs_chem()`.

```{r include=FALSE}
DBI::dbDisconnect(watina)
```

